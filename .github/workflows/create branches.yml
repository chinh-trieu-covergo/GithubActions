name: Create gamma branch in multiple CoverGo repositories

on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: 'Branch name to create'
        required: true
        type: string

jobs:
  create-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      matrix:
        repository:
          - CoverGo/Reference
          - CoverGo/RequestManager
          # Add more repositories here as needed
          # - CoverGo/Repository3
          # - CoverGo/Repository4
          # ... up to 100 repositories
    steps:
      - name: Checkout ${{ matrix.repository }}
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repository }}
          token: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      - name: Create and push branch in ${{ matrix.repository }}
        run: |
          git config user.name "coverbot"
          git config user.email "infrastructure@covergo.com"
          
          # Get the default branch (main or master)
          # Try to get the default branch from remote HEAD
          DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "")
          
          # If that fails, try common branch names
          if [ -z "$DEFAULT_BRANCH" ]; then
            if git show-ref --verify --quiet refs/remotes/origin/main; then
              DEFAULT_BRANCH="main"
            elif git show-ref --verify --quiet refs/remotes/origin/master; then
              DEFAULT_BRANCH="master"
            else
              echo "❌ Error: Could not determine default branch for ${{ matrix.repository }}"
              exit 1
            fi
          fi
          
          echo "Using default branch: $DEFAULT_BRANCH"
          
          # Checkout the default branch
          git checkout $DEFAULT_BRANCH
          git pull origin $DEFAULT_BRANCH
          
          # Check if branch already exists
          if git show-ref --verify --quiet refs/heads/${{ inputs.branch_name }}; then
            echo "⚠️  Branch '${{ inputs.branch_name }}' already exists locally, checking it out"
            git checkout ${{ inputs.branch_name }}
            git pull origin ${{ inputs.branch_name }} || true
          else
            # Create new branch
            git checkout -b ${{ inputs.branch_name }}
          fi
          
          # Push the new branch
          git push -u origin ${{ inputs.branch_name }}
          
          echo "✅ Successfully created/updated branch '${{ inputs.branch_name }}' in ${{ matrix.repository }}"
  update-docker-image-request-manager:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout RequestManager repository
        uses: actions/checkout@v4
        with:
          repository: CoverGo/RequestManager
          token: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 1
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
  
      - name: Replace image in docker
        id: replace
        run: |
          Tests_Acceptance_Amazon_FILE_PATH="docker-compose-tests-acceptance-amazon.yml"

          OLD_AUTH_IMG="image: ghcr.io/covergo/auth:master"
          NEW_AUTH_IMG="image: ghcr.io/covergo/auth:${{ inputs.branch_name }}"

          echo "Files in current directory:"
          ls -1

          
          # Check if the old auth image exists in the file
          if ! grep -q "$OLD_AUTH_IMG" "$Tests_Acceptance_Amazon_FILE_PATH"; then
            echo "❌ Error: Could not find old auth image in $Tests_Acceptance_Amazon_FILE_PATH"
            echo "Expected: $OLD_AUTH_IMG"
            exit 1
          fi          
          
          echo "Current auth image: $OLD_AUTH_IMG"
          echo "New auth image: $NEW_AUTH_IMG"
          
          # Replace old auth image in the file using Python for reliable string replacement
          python3 << EOF
          import re
          import os
          print("Files in current directory:")
          print(os.listdir())

          import os
          file_path = os.environ.get("Tests_Acceptance_Amazon_FILE_PATH")
          old_auth_img = os.environ.get("OLD_AUTH_IMG")
          new_auth_img = os.environ.get("NEW_AUTH_IMG")
          print("File path:", file_path)
          print("Old auth image:", old_auth_img)
          print("New auth image:", new_auth_img)

          
          with open(file_path, 'r') as f:
              content = f.read()
          
          # Replace old auth image          
          new_content = content.replace(old_auth_img, new_auth_img)
          
          with open(file_path, 'w') as f:
              f.write(new_content)
          EOF
          
          # Verify the change
          UPDATED_AUTH_IMG=$(grep "$NEW_AUTH_IMG" "$Tests_Acceptance_Amazon_FILE_PATH")
          if [ "$UPDATED_AUTH_IMG" != "$NEW_AUTH_IMG" ]; then
            echo "❌ Error: Auth image update failed. Expected $NEW_AUTH_IMG, got $UPDATED_AUTH_IMG"
            exit 1
          fi
          
          echo "✅ Successfully updated auth image from $OLD_AUTH_IMG to $NEW_AUTH_IMG"
          echo "old_auth_img=$OLD_AUTH_IMG" >> $GITHUB_OUTPUT
          echo "new_auth_img=$NEW_AUTH_IMG" >> $GITHUB_OUTPUT

      - name: Commit and push changes
        run: |          
          BRANCH_NAME="${{ inputs.branch_name }}"
          
          # Check if there are any changes
          if git diff; then
            echo "⚠️  No changes detected"
            exit 0
          fi
          
          # Stage the file
          git add .
          
          # Commit the changes
          git commit -m "chore: update docker image for $BRANCH_NAME"
          
          # Push to the branch
          git push origin "$BRANCH_NAME"
          
          echo "✅ Successfully committed and pushed docker image update to $BRANCH_NAME"
